#!/bin/bash
#------------------------------------------------------------
# initd script for running services without start-stop-daemon
# (c) Wolfgang Ziegler, nuppla@zites.net, drunomics GmbH
#  This forked version by David Kebler d@kebler.net, 2017
#------------------------------------------------------------


CMD="$2"

# if one of these then must be no conf passed to make it syncd.conf
if [[ "$1" =~ ^(start|stop|restart|status|run|log)$ ]]; then
  CONF_FILE="syncd"
  CMD="$1"
else
  CONF_FILE="$1"
fi

echo conf file: $CONF_FILE  command: $CMD


SYNCD_CONFIG_DIR=$PWD
SCRIPT=`readlink -f $0`
DAEMON_NAME=syncd
LINK=`readlink -f $0`
SCRIPT_DIR=`dirname $LINK`

CONF_PATH=$SCRIPT_DIR/jobs/$CONF_FILE.conf

# look in jobs directory of syncd folder or in syncd folder within directory being synced
if [ ! -e $CONF_PATH ]; then
  if [ ! -e syncd/$CONF_FILE.conf ]; then
    if [ ! -e $CONF_FILE.conf ]; then
      echo "Unable to find syncd configuration file \"$CONF_FILE\"."
      exit 1
    fi
    CONF_PATH=$PWD/$CONF_FILE.conf
  else
    CONF_PATH=$PWD/syncd/$CONF_FILE.conf
  fi
fi

# source the config file here
echo loading config file: $CONF_PATH

. $CONF_PATH

if [ -z "$WATCH_DIR" ]; then WATCH_DIR=$(dirname `dirname $CONF_PATH`);fi
echo watching $WATCH_DIR for changes

if [ -z "$SSH_HOST" ]; then TARGET=$TARGET_DIR; else TARGET=$SSH_USER@$SSH_HOST:$TARGET_DIR; fi

#echo target is: $TARGET
# RSYNC_EXCLUDE in conf file be sure to add --exclude fileordir  for each one, can be multiple
COMMAND="rsync $RSYNC_OPTIONS $RSYNC_EXCLUDE $WATCH_DIR/ $TARGET"
# echo $COMMAND

# pid files go in the same directory as .conf
CONF_DIR=`dirname $CONF_PATH`
PIDFILE=$CONF_DIR/$CONF_FILE.pid
LOGFILE=$CONF_DIR/$CONF_FILE.log
#echo $PIDFILE $LOGFILE

# uncomment for debugging
# exit 1

case $CMD in
  start)
    if [ -e ${PIDFILE} ] && ( ps -p `cat $PIDFILE` > /dev/null ); then
      echo "$DAEMON_NAME is already running."
      exit 1;
    fi
    export WATCH_EXCLUDE
    export WATCH_VERBOSE
    export WATCH_DIR
    $SCRIPT_DIR/watch.sh $COMMAND >> $LOGFILE &
    echo "$!" > $PIDFILE
    echo "Starting $DAEMON_NAME..."
  ;;

  stop)
    if [ ! -e ${PIDFILE} ] || ( ! ps -p `cat $PIDFILE` > /dev/null ); then
      echo "$DAEMON_NAME is not running."
      exit 1;
    fi

    echo "Stopping $DAEMON_NAME..."
    PID=`cat $PIDFILE`
    CHILD_PIDS=$(pgrep -P $PID);
    kill $PID 2> /dev/null || echo Killing process failed, not running?
    # Wait half a second and Kill child PIDs to be sure they are gone.
    sleep 0.5
    kill $CHILD_PIDS 2> /dev/null
    rm $PIDFILE
  ;;
  restart)
    $SCRIPT $1 stop
    $SCRIPT $1 start
  ;;

  status)
    if [ -e ${PIDFILE} ] && ( ps -p `cat $PIDFILE` > /dev/null ); then
      echo "$DAEMON_NAME is running."
    else
      echo "$DAEMON_NAME is not running."
    fi
  ;;

  run)
    echo $COMMAND
    read -p "Ok to run this command? [yn]" ans
    if [ $ans = y ] ; then
      $COMMAND && echo Done
    fi
  ;;

  log)
    tail -f $LOGFILE
  ;;

  *)
    echo "Usage: $0 {start|stop|restart|status|run|log}"
    exit 3
  ;;
esac
